https://studfiles.net/preview/3988456/page:3/
 Пример фрагмента программы объявления указателя
Type A= array [1..100] of integer;
TA= ^ A ; {тип указатель на массив}
Var
P1: ^ integer; {переменная типа указатель на целое число}
P2: ^ real; {переменная типа указатель на вещественное число}
Указатель, не связанный с каким-либо конкретным типом данных, называется нетипизированным указателем. 
Для описания нетипизированного указателя в Паскале существует стандартный тип pointer. Описание такого указателя имеет вид:
Имя-переменной: pointer;

С помощью нетипизированных указателей удобно динамически размещать данные, структура и тип которых меняются в ходе выполнения 
программы.

Значения указателей – адреса переменных в памяти. Адрес занимает четыре байта и хранится в виде двух слов, одно из которых 
определяет сегмент, второе – смещение.

Следовало бы ожидать, что значение одного указателя можно передать другому. На самом деле можно передавать значения 
только между указателями, связанными с одним типом данных. Указатели на различные типы данных имеют различный тип, 
причем эти типы несовместимы.

http://natalia.appmat.ru/c%26c%2B%2B/assembler.html
 16-битные регистры могли адресовать только 64 Кб оперативной памяти, что явно недостаточно для более или менее приличной 
 программы. Поэтому память программе выделялась в виде нескольких сегментов, которые имели размер 64 Кб. При этом абсолютные
 адреса были 20-битными, что позволяло адресовать уже 1 Мб оперативной памяти. Возникает вопрос – как имея 16-битные регистры
 хранить 20-битные адреса? Для решения этой задачи адрес разбивался на базу и смещение. База – это адрес начала сегмента, 
 а смещение – это номер байта внутри сегмента. На адрес начала сегмента накладывалось ограничение – он должен был быть кратен 16.
 При этом последние 4 бита были равны 0 и не хранились, а подразумевались. Таким образом, получались две 16-битные части адреса. 
 Для получения абсолютного адреса к базе добавлялись четыре нулевых бита, и полученное значение складывалось со смещением.

Сегментные регистры использовались для хранения адреса начала сегмента кода (CS – code segment), сегмента данных 
(DS – data segment) и сегмента стека (SS – stack segment). Регистры ES, FS и GS были добавлены позже. 

https://studfiles.net/preview/3988456/page:3/

 Пример фрагмента программы объявления указателя различных типов

Var p1,p2: ^integer;
p3: ^real;
pp: pointer;
………
p1:= p2; {допустимое действие }
p1:= p3; {недопустимое действие}
Однако это ограничение не распространяется на нетипизированный указатель. В программе допустимы будут следующие действия:
pp:= p3;
p1:= pp;
Выделение и освобождение динамической памяти
Вся ДП рассматривается как сплошной массив байтов, который называется кучей.
Расположение кучи в памяти ПК.
РИС.

 Существуют стандартные переменные, в которых хранятся значения адресов начала, конца и текущей границы кучи:

    Heaporg – начало кучи;

    Heapend – конец кучи;

    Heapptr – текущая граница незанятой ДП.

Выделение памяти под динамическую переменную осуществляется процедурой:
New (переменная_типа_указатель)
В результате обращения к этой процедуре указатель получает значение, соответствующее адресу в динамической памяти, начиная 
с которого можно разместить данные.
Пример фрагмента программы объявления указателя различных типов
Var i, j: ^integer;
r: ^real;
begin
new( i); {после этого указатель i приобретает значение адреса Heapptr, а Heapptr смещается на 2 байта}
……………
new( r) ; { r приобретает значение Heapptr, а Heapptr смещается на 6 байт}
Графически действие процедуры new можно изобразить так:
РИС.
 Освобождение динамической памяти осуществляется процедурой:
Dispose (переменная_типа_указатель)

Пример фрагмента программы процедуры Dispose
Dispose (i); {возвращает в кучу 2 байта}
Dispose (r); {возвращает в кучу 6 байт}
Следует помнить, что повторное применение процедуры dispose к свободному указателю может привести к ошибке.
Процедура dispose освобождает память, занятую динамической переменной. При этом значение указателя становится неопределенным.
РИС.
Любые действия над указателем в программе располагаются между процедурами new и dispose.
При использовании динамически распределяемых переменных часто возникает общая проблема, называемая утечкой динамической памяти. 
Утечка памяти – это ситуация, когда пространство выделяется в динамически распределяемой памяти и затем теряется – 
по каким-то причинам ваш указатель не указывает больше на распределенную область, так что вы не можете освободить пространство. 
Общей причиной утечек памяти является переприсваивание динамических переменных без освобождения предыдущих. 
Простейшим случаем является следующий:
Пример фрагмента программы
var IntPointer :^ Integer;
begin
New (IntPointer);
New (IntPointer);
end.
При первом вызове New в динамически распределяемой памяти выделяется 2 байта, и на них устанавливается указатель IntPointer. 
Второй вызов New выделяет другие 2 байта, и IntPointer устанавливается на них. Теперь у вас нет указателя, 
ссылающегося на первые 2 байта, поэтому вы не можете их освободить. В программе эти байты будут потеряны.

Указатели Си
http://cdeblog.ru/ukazateli-na-funkcii-v-si

Указатель - это переменная, которая содержит в себе адрес другой переменной, на которую указывает. 
Если проводить грубую аналогию с файловой системой в Windows, то указатель - это ярлык, а файл на который он указывает - 
переменная, размышляя дальше можно сказать что функция - это программа на компьютере, а ярлык для запуска программы - 
указатель на функцию.

Объявляются указатели следующим образом:

uint16_t *pointer_ui16 = &variable;
void *pointer_Void
char *str = "Строка";

Здесь в первой строке объявляется указатель на тип uint16_t (целый без знаковый тип размером в 16 бит) и говорится, 
что он ссылается на переменную variable. Как уже заметили есть ещё оператор &, он то как раз и возвращает адрес нашей переменной.

uint16_t variable = 0x1234; // переменная равна 0x1234 храниться по адресу 0x20001F00
uint16_t *pointer = &variable;

printf("%x", pointer);      // Здесь будет выведен адрес переменной: 0x20001F00
printf("%x", *pointer);     // Здесь будет выведено значение переменной: 0x1234
variable = 0x4678;
printf("%x", pointer);      // снова 0x20001F00
printf("%x", *pointer);     // а тут уже 0x4678

То есть, для доступа к данным на которые ссылается указатель необходимо написать знак "*". С этим вроде разобрались.
Теперь о функциях. С ними тоже не сильно сложно. Для начала пример объявления, рассмотрим всего 4:

void ( *func_name_1 )();                        // 1
void ( *func_name_2 )( void );                  // 2
void ( *func_name_3 )( uint8_t, int16_t));      // 3
uint16_t ( *func_name_4 )( uint8_t, int16_t);   // 4

    указатель на функцию ничего не возвращающую и с неизвестным количеством и типом параметров;
    указатель на функцию ничего не возвращающую и ничего не принимающую;
    указатель на функцию ничего не возвращающую, но принимающую два аргумента типами uint8_t и int16_t;
    указатель на функцию возвращающую значение типа uint16_t и принимающую два аргумента типами uint8_t и int16_t

Главное не забыть окружить скобками указатель, иначе получится не указать на функцию, а функция возвращающая указатель:

int16_t *func_1 ( void );     // функция func_1 возвращающая указатель на тип int16_t
int16_t ( *func_2 )( void );  // указатель func_2 на функцию возвращающую тип int16_t

Принцип использования можно посмотреть в примере:

// функция которая находит абсолютное значение
uint16_t usr_ABS(int16_t value)  { return (value > 0) ? (value) : (-value); }
// функция которая возводит в квадрат
uint16_t usr_POW2(int16_t value) { return value*value; }

uint16_t (*func)(int16_t);       // Указатель

int main ( void )
{
    // Присваиваем указателю адрес на функцию usr_ABS
    // Кстати говоря можно делать и так func = usr_ABS, 
    // так как просто имя функции и будет означать её адрес
    func = &usr_ABS;

    printf("%d", usr_ABS(-400)); // выводит 400 использую функцию
    printf("%d", (*func)(-400)); // выводит 400 использую указатель

    func = &usr_POW2; // а теперь указывает на usr_POW2

    printf("%d", usr_ABS(30));   // выводит 30
    printf("%d", (*func)(30));   // выводит 900
}

Получается что мы динамически изменили логику программы. Согласитесь не плохо и довольно интересно.

Как это применять вам подскажет логика и собственное чувство вкуса, самое главное теперь понятно как оно работает.

Для более глубокого понимания советую почитать книгу Брайана Кернигана и Денниса Ритчи (ссылка), либо освежить знания.
