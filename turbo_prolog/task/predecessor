http://masters.donntu.org/2009/fvti/bandurka/library/article3.htm

Для всех X и Z, X — предок Z, если X — родитель Z.
Это непосредственно переводится на Prolog как
predecessor( X, Z) :- parent( X, Z).
Второе правило сложнее, поскольку построение цепочки отношений parent может вызвать некоторые трудности. Один из способов определения отдаленных родственников мог бы заключаться в том, чтобы отношение predecessor определялось бы множеством предложений:
predecessor( X, Z) :- parent( X, Z).
predecessor( X, Z) :- parent( X, Y), parent( Y, Z).
predecessor( X, Z) :- parent( X, Y1), parent( Yl, Y2), parent( Y2, Z).
predecessor( X, Z) :- parent( X, Y1), parent( Y1, Y2), parent( Y2, Y3), parent( Y3, Z).
. . .
Эта программа длинна и, что более важно, работает только в определенных пределах. Она будет обнаруживать предков 
лишь до определенной глубины фамильного дерева, поскольку длина цепочки людей между предком и потомком ограничена длиной
наших предложений в определении отношения.
Существует, однако, корректная и элегантная формулировка отношения predecessor — корректная в том смысле, что будет 
работать для предков произвольной отдаленности. Ключевая идея здесь — определить отношение predecessor через него самого:
Для всех X и Z, X — предок Z, если существует Y, такой, что X — родитель Y и Y — предок Z.
Предложение Prolog, имеющее тот же смысл, записывается так:
predecessor( X, Z) :- parent( X, Y), predecessor( Y, Z).
Теперь мы построили полную программу для отношения predecessor, содержащую два правила: одно для ближайших предков и
другое для отдаленных предков. Здесь приводятся они оба вместе:
predecessor( X, Z) :- parent( X, Z).
predecessor( X, Z) :- parent( X, Y), predecessor( Y, Z).
Ключевым моментом в данной формулировке было использование самого отношения predecessor в его определении. 
Такое определение может озадачить — допустимо ли при определении какого-либо понятия использовать его же, 
ведь оно определено еще не полностью. Такие определения называются рекурсивными. Логически они совершенно корректны и понятны. 
Но будет ли в состоянии Prolog-система использовать рекурсивные правила? Оказывается, что Prolog-система очень легко может обрабатывать
рекурсивные определения. На самом деле, рекурсия — один из фундаментальных приемов программирования на Prolog. 
Без рекурсии с его помощью невозможно решать задачи сколько-нибудь ощутимой сложности.

fa(aa,bb).
fa(bb,cc).
fa(cc,dd).
fa(dd,ee).
fa(ee,ff).
fa(ff,gg).
| ?- fa(F,ee),fa(G,F).
F = dd
G = cc ? ;
no


predecessor( X, Z) :- fa( X, Z).
predecessor( X, Z) :- fa( X, Y), predecessor( Y, Z).

grandfa(X,Y) :- fa(X,Z),fa(Z,Y).

https://it-iatu.ru/is/predstavlenie-znaniy-v-is/prolog_pravila_rekursivnye_pravila

Рассмотрим следующую БД:

мать(каролина,юлия).
мать(каролина, альбертина).
мать(мари,проспер).
мать(анна,каролина).
отец(проспер,юлия).
отец(проспер,альбертина).
отец(альфонс,проспер).
отец(андре,каролина).
дед(Х,Y):-отец(Х,Z), мать(Z,Y).
дед(Х,Y):-отец(Х,Z), отец(Z,Y).
бабка(Х,Y):-мать(Х,Z), мать(Z,Y).
бабка(Х,Y):-мать(Х,Z), отец(Z,Y).
Отношения мать и отец заданы фактами, а отношение дед и бабка определяются с помощью правил.
На вопрос 
? - дед(альфонс,юлия). 
ответов среди фактов нет (ни один факт не соответствует предикату вопроса).
Но заголовки некоторых правил соответствуют этому предикату.

fa(aa,bb).
fa(bb,cc).
fa(cc,dd).
fa(dd,ee).
fa(ee,ff).
fa(ff,gg).
grandfa(X,Y) :- fa(X,Z),fa(Z,Y).

Рекурсивные правила
База данных семья должна отвечать на вопрос является ли Х предком Y. Определение предиката «быть предком» рекурсивно. 
Для предков по женской линии соответствующие правила на Прологе записываются так. 
предок(Х,Y):-мать(Х,Y). предок(Х,Y):-мать(Х,Z),предок(Z,Y). 
Такие рекурсии разрешается использовать, иначе язык был бы слишком примитивным. 


