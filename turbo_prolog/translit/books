paul brna 107

подчеркивания относятся к различным переменным. Надо отметить, что в этом утверждении
...
подчеркивания не относятся к одному объекту.
Например, вот два варианта member/2
know_both_parents(X):-
 mother(_,X),
 father(_,X). 
примерно означает следующее:"мы знаем родителей Х, если это мать Х и отец Х"



kzaska 32
For example,
f(X) :- a(X), b(X); c(X), d(X).
is equivalent to
f(X) :- (a(X), b(X)); (c(X), d(X)).
and means, “To satisfy f(X) , find an X that satisfies either a(X) and b(X) , or else
c(X) and d(X) .” The parentheses make it easier to understand. O’Keefe (1990:101)
recommends that, instead, you should write:
f(X) :- ( a(X), b(X)
; c(X), d(X)
).

Lec30

Cut-символ
Наиболее используемой логической фичей Пролога является cut-символ “!”, который в цели, факте или правиле "отрезает” перебор с
возвратами (backtracking).
Выбранные правила и привязки оказываются "заморожены".
Например, в выражении
x(A) :- y(A,B), z(B), ! , v(B,C).
после ! мы не можем вернуться к y(A,B) или z(B)

Иногда полезно иметь несколько ! в правиле. Это позволяет нам найти частичное решение, зафиксировать его, найти дальнейшее решение, 
затем зафиксировать его и т. д.
Например, в правиле
a(X) - b(X), !, c(X,Y), ! , d(Y).
мы сначала попытаемся выполнить b (X), возможно попробовав несколько фактов или правил, которые
определяют отношение b. Как только у нас есть решение для b (X), мы "отрезаем" его вместе
с привязкой для X. Затем мы пытаемся выполнить c (X,Y), используя фиксированную привязку для X, (возможно,
нескольких привязок для Y), пока c (X,Y) не выполнен.

! может улучшить эффективность, предотвращая бесполезные или избыточные поиски (переборы).

bk 101 
10.8 How to glue two list together 

Можно решить эту задачу в процедурной манере, используя деконструктор списка:

отделить голову a первого списка [a,b]
 решить подзадачу - склеить [b] и [c,d,e]
  присоединить голову a обратно (в начало результирующего списка)
  
Но необходимо решить подзадачу:
отделить голову b первого списка [b]
 решить подзадачу - склеить [] и [c,d,e]
  присоединить голову a обратно (в начало результирующего списка)
  
Но необходимо решить подзадачу:
 склеить [] и [c,d,e] - это просто... список [c,d,e].  

Это можно решить рекурсией:
Снять голову с первого списка и хранить ее до тех пор, пока мы не решим подзадачу склеивания остальной части 
первого списка со вторым списком. Для решения подзадачи достаточно просто применить тот же метод.

Вот код:
 aappend([],List2,List2).
  aappend([Head|List1],List2,[Head|List3]) :-
   aappend(List1,List2,List3).
